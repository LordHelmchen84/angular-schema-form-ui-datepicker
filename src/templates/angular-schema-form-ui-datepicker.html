<div
    class="form-group has-feedback schema-form-ui-datepicker"
    ng-class="{
       'has-error': form.disableErrorState !== true && hasError(),
       'has-success': form.disableSuccessState !== true && hasSuccess(),
       'has-feedback': form.feedback !== false,
       'required': form.required === true
     }">

    <!-- Create your own form options -->
    <label class="control-label {{::form.labelHtmlClass}}" ng-class="{'sr-only': !showTitle()}" for="{{::fieldId(true, false)}}">{{form.title}}</label>

    <ui-datepicker
        name="{{::fieldId(true, false)}}"
        ng-attr-placeholder="{{::form.placeholder}}"
        id="{{::fieldId(true, false)}}"
        datepicker-options="{{form.dateOptions}}"
        datename="{{::fieldId(true, false)}}"
        ng-disabled="form.readonly"
        sf-changed="form"
        ng-model="ngModel"
        sf-field-model
        schema-validate="form"></ui-datepicker>

    <!-- sf-field-model let's the ngModel builder know that you want a ng-model that matches against the form key here -->
    <!-- schema-validate="form" validates the form against the schema -->
    <span
        ng-if="form.feedback !== false"
        class="form-control-feedback"
        ng-class="evalInScope(form.feedback) || {'glyphicon': true, 'glyphicon-ok': form.disableSuccessState !== true && hasSuccess(), 'glyphicon-remove': form.disableErrorState !== true && hasError() }"
        aria-hidden="true"></span>

    <span ng-if="hasError() || hasSuccess()" id="{{::fieldId(true, true) + '-status'}}" class="sr-only">{{ hasSuccess() ? '(success)' : '(error)' }}</span>

    <div class="help-block" sf-message="form.description"></div>
    <!-- Description & Validation messages -->

</div>
